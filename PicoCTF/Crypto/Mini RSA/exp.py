e = 3
M = 631371953793368771804570727896887140714061729769155038068711341335911329840163136
k = 1
# p = 1461849912200000206276283741896701133693
# q = 431899300006243611356963607089521499045809

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x-(b//a)*y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m

while(True):
    if (1 + k * M) % e == 0:
        print('k = ', k, ' and d = ', (1 + k * M) / e)
        break
    else:
        k += 1

d = modinv(e, M)
c = 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808147130204332030239454609548193370732857240300019596815816006860639254992255194738107991811397196500685989396810773222940007523267032630601449381770324467476670441511297695830038371195786166055669921467988355155696963689199852044947912413082022187178952733134865103084455914904057821890898745653261258346107276390058792338949223415878232277034434046142510780902482500716765933896331360282637705554071922268580430157241598567522324772752885039646885713317810775113741411461898837845999905524246804112266440620557624165618470709586812253893125417659761396612984740891016230905299327084673080946823376058367658665796414168107502482827882764000030048859751949099453053128663379477059252309685864790106
n = 631371953793368771804570727896887140714495090919073481680274581226742748040342637
plain = pow(c, d, n)
print(plain)
print(hex(plain))
print(bytearray.fromhex(hex(plain)[2:]))